var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
* name
*/
var riggerLayaSA;
(function (riggerLayaSA) {
    var SyncTimeLine = /** @class */ (function (_super) {
        __extends(SyncTimeLine, _super);
        function SyncTimeLine() {
            var _this = _super.call(this, new Laya.TimeLine()) || this;
            _this.startTimeOrLabel = null;
            _this.loop = null;
            return _this;
        }
        Object.defineProperty(SyncTimeLine.prototype, "scale", {
            get: function () {
                return this.mContent.scale;
            },
            set: function (s) {
                this.mContent.scale = s;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 控制一个对象，从当前点移动到目标点。
         * @param	target		要控制的对象。
         * @param	props		要控制对象的属性。
         * @param	duration	对象TWEEN的时间。
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        SyncTimeLine.to = function (target, props, duration, ease, offset) {
            var ret = new SyncTimeLine();
            ret.to(target, props, duration, ease, offset);
            return ret;
        };
        /**
         * 从 props 属性，缓动到当前状态。
         * @param	target		target 目标对象(即将更改属性值的对象)
         * @param	props		要控制对象的属性
         * @param	duration	对象TWEEN的时间
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）
         */
        SyncTimeLine.from = function (target, props, duration, ease, offset) {
            var ret = new SyncTimeLine();
            ret.from(target, props, duration, ease, offset);
            return ret;
        };
        /**
         * 控制一个对象，从当前点移动到目标点。
         * @param	target		要控制的对象。
         * @param	props		要控制对象的属性。
         * @param	duration	对象TWEEN的时间。
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        SyncTimeLine.prototype.to = function (target, props, duration, ease, offset) {
            this.mContent.to(target, props, duration, ease, offset);
            return this;
        };
        /**
         * 从 props 属性，缓动到当前状态。
         * @param	target		target 目标对象(即将更改属性值的对象)
         * @param	props		要控制对象的属性
         * @param	duration	对象TWEEN的时间
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）
         */
        SyncTimeLine.prototype.from = function (target, props, duration, ease, offset) {
            this.mContent.from(target, props, duration, ease, offset);
            return this;
        };
        /**
         * 在时间队列中加入一个标签。
         * @param	label	标签名称。
         * @param	offset	标签相对于上个动画的偏移时间(单位：毫秒)。
         */
        SyncTimeLine.prototype.addLabel = function (label, offset) {
            this.mContent.addLabel(label, offset);
            return this;
        };
        /**
         * 移除指定的标签
         * @param	label
         */
        SyncTimeLine.prototype.removeLabel = function (label) {
            this.mContent.removeLabel(label);
        };
        /**
         * 动画从整个动画的某一时间开始。
         * @param	time(单位：毫秒)。
         */
        SyncTimeLine.prototype.gotoTime = function (time, immediately) {
            if (immediately === void 0) { immediately = false; }
            return this.play(time, false, immediately);
        };
        /**
         * 从指定的标签开始播。
         * @param	Label 标签名。
         */
        SyncTimeLine.prototype.gotoLabel = function (Label, immediately) {
            if (immediately === void 0) { immediately = false; }
            return this.play(Label, false, immediately);
        };
        /**
         * 暂停整个动画。
         */
        SyncTimeLine.prototype.pause = function () {
            this.mContent.pause();
        };
        /**
         * 恢复暂停动画的播放。
         */
        SyncTimeLine.prototype.resume = function () {
            this.mContent.resume();
        };
        /**
         * 播放动画。
         * @param	timeOrLabel 开启播放的时间点或标签名。
         * @param	loop 是否循环播放。
         * @param	immediately 是否立即开始播放，默认为false,如果为false，则要在wait后才会开始播放
         *
         */
        SyncTimeLine.prototype.play = function (timeOrLabel, loop, immediately) {
            if (immediately === void 0) { immediately = false; }
            if (!this.mContent)
                return;
            this.startTimeOrLabel = timeOrLabel;
            this.loop = loop;
            if (immediately) {
                this.doPlay();
            }
            return this;
        };
        SyncTimeLine.prototype.cancel = function (reason) {
            if (!this.mContent)
                return;
            this.mContent.pause();
            _super.prototype.cancel.call(this, reason);
        };
        Object.defineProperty(SyncTimeLine.prototype, "index", {
            /**
             * @private
             * 得到帧索引
             */
            get: function () {
                return this.mContent.index;
            },
            /**
             * @private
             * 设置帧索引
             */
            set: function (idx) {
                this.mContent.index = idx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncTimeLine.prototype, "total", {
            /**
             * 得到总帧数。
             */
            get: function () {
                return this.mContent.total;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 重置所有对象，复用对象的时候使用。
         */
        SyncTimeLine.prototype.reset = function () {
            this.mContent.reset();
            _super.prototype.reset.call(this);
            return this;
        };
        /**
         * 彻底销毁此对象。
         */
        SyncTimeLine.prototype.destroy = function () {
            this.dispose();
        };
        SyncTimeLine.prototype.dispose = function () {
            this.mContent.destroy();
            this.mContent = null;
            _super.prototype.dispose.call(this);
        };
        SyncTimeLine.prototype.startTask = function () {
            _super.prototype.startTask.call(this);
            this.doPlay();
            return this;
        };
        SyncTimeLine.prototype.onComplete = function () {
            this.done();
        };
        SyncTimeLine.prototype.onLabel = function () {
        };
        SyncTimeLine.prototype.doPlay = function () {
            if (!this.mContent.hasListener(Laya.Event.COMPLETE)) {
                this.mContent.once(Laya.Event.COMPLETE, this, this.onComplete);
            }
            this.mContent.play(this.startTimeOrLabel, this.loop);
            this.startTimeOrLabel = this.loop = null;
        };
        SyncTimeLine.prototype.isLabel = function (timeOrLabel) {
            if (typeof timeOrLabel === "string") {
                return true;
            }
            return false;
        };
        return SyncTimeLine;
    }(riggerIOC.WaitableTask));
    riggerLayaSA.SyncTimeLine = SyncTimeLine;
})(riggerLayaSA || (riggerLayaSA = {}));
